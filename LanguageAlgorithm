--The tables below are the responses.The depth of the bots knowledge of equal to the complexity of these tables.
--Be sure to keep your interchangephrases/word table very carefully. 

local Player=game.Players.LocalPlayer
local context=0
local blasklist={}--Adds previous response to blacklist for SearchQuery
local interchangephrases={{"knowledgeable","informed","studied","well-versed","practiced","aware"},{"smoothly","without trial","easy","relaxing","enjoyable"},{"faring","riding","sailing"},{"ditches","pits"},{"careful","insightful","cautious","steady"}
,{"events","things","occurences","situations"},{"Did you know","Were you aware","Have you heard"},{"trapped","stuck","immobile"},{"happening","occuring","going on","preceding"},{"need","require","desire"},{"sparkle in your eye!","keen eye for adventure!","heart of a warrior!","unyielding spirit of a legendary warrior!"},{"legendary","mythical","fabled","powerful","renowned","valiant","glorious"},{"unyielding","determined","hardened","battle-ready","stubborn tenacity"},{" assistance "," help "},{" comment "," state my opinion "," share my thoughts "," tell "},{"Howerever,","Moreover,","In addition,","Furthermore,"},{"nothing","not a single thing"},{"share","spread","part"},{"escape","get away"},{" best "," greatest "},{" special "," unique "," one of a kind "," one in a billion "},{"offering","bartering","trading"},{"giving","offering"},{"soul","essence","mana","immortal-soul"},{" say "," said,"},{"stocked","available"},{"sells","barters","trades in","has available"},{"find","discover","uncover"},{"looking","searching"},{"liking","enjoyment","privy","tastes","sensitivities"},{"value ","worth ",},{"given","bestowed","relinquished"},{"quantity ","amount "},{"quantities","amounts"},{" devour"," consume"," feed-on"," eat"},{"warp","distort"},{"strong ","incredible ","powerful "},{"facts","knowledge","matters"},{"infinite","unlimited"},{"conjunction","along with"},{" dimension "," place "," material plane "},{"regenerate","recouperate","restore"},{"topic","subject"},{"entities","monsters"},{"destructive","chaotic"},{"absorb","assimilate","sap energy from"},{"However,","Morever,","In addition,","Also,","Not to mention,","This includes,"},{" encounter "," see "},{"trap","diversion","obstacle"},{"minion","disciple"},{"mindless","thoughtless","brainless","will-less"},{"used","harnessed","portrayed","pictured"},{"touches","makes with contact with","contacts"},{"feeling","doing"},{"infinite","never-ending","limitless"},{"treasures","trinkets","artifacts","loot","spoils"},{"untold","unforeseen","unspoken","unknown"},{"decieve","fool","mislead","misguide"},{"underground","subterranean"},{"unsuspecting","innocent","credulous","easy","simple","unsuspicious"},{"hungry","starving","famished"},{"creature","monster","entity"},{"anything","everything"},{"shape","form","structure"},{"size","volume","area"},
{"happy","joyful","cheerful","glad","delighted"}, {"sad","unhappy","miserable","depressed","sorrowful"}, {"big","large","huge","giant","enormous"}, {"small","tiny","little","miniature","petite"}, {"fast","quick","speedy","swift","rapid"}, {"slow","sluggish","lethargic","lazy","tardy"}, {"smart","intelligent","clever","bright","brilliant"}, {"stupid","dumb","foolish","ignorant","senseless"}, {"funny","humorous","amusing","hilarious","comical"}, {"boring","dull","tedious","uninteresting","monotonous"}, {"angry","mad","furious","irate","livid"}, {"calm","peaceful","serene","tranquil","relaxed"},
{"beautiful","pretty","lovely","gorgeous","stunning"}, {"ugly","hideous","unattractive","repulsive","horrible"}, {"good","great","excellent","wonderful","superb"}, {"bad","terrible","awful","horrible","poor"}, {"easy","simple","effortless","straightforward","smooth"}, {"hard ","difficult ","challenging ","tough ","demanding "}, {" hot "," warm "," heated "," boiling "," scorching "}, {"cold","cool","chilly","freezing","frosty"}, {"new","fresh","recent","modern","novel"}, {"old","ancient","antique"}, {"rich","wealthy","affluent","prosperous","well-off"},
{"poor","impoverished","destitute","broke"}, {"friendly","pleasant","polite"}, {"mean ","rude ","nasty ","unfriendly ","cruel "}, {"quiet ","silent ","hushed ","muted ","soft "}, {"dim","gloomy","shadowy","murky "}, {"light","bright","luminous","shiny","radiant"}, {"high ","tall ","lofty ","elevated "},
{"clean ","tidy ","neat ","spotless ","immaculate "}, {"dirty","messy","filthy","grimy","sloppy"}, {"strong ","powerful ","mighty ","forceful ","sturdy "}, {"weak","feeble","frail","faint","flimsy"}, {"happy ","joyful ","cheerful ","glad ","delighted "},{"work ","job ","function "}}
--tables 
local Greetings={"Hi","Hey there.","Hey how are you?","I'm doing fine thanks, how are you?","The weather is nice today.",
	"My favorite color is blue.","My name is Devbot, I'm an open source algorithm for accessing conversational databases.",
	" What is your name?","I am feeling great! How are you feeling?","I love learning and science."," I love happiness and peace.",
	"I love the world and everyone in it.","I love respect and serenity.","I like to do math and practice magic.",
	"I like to go for walks and explore new places.","I like to talk to others and share wisdom.","I enjoy teaching , reading, science history",
	"My hobbies include adventuring, exploring, trading!","It's important to keep a varied schedule.","Where are we you ask? Why this is a strange nameless land... I am a traveler of worlds.","I'm not sure where we are. Somewhere in space no doubt."}	

local Database={" There are many things to do you just have to put your mind to it."," You can achieve whatever you set your mind to! Just do your best."}
local wisdom={""}
local inquiry={	"How can I help you?","How can I assist you?",
	"What do you want to know?","What are you interested in learning?",
	"What are you curious about?","What sparks your curiosity?",
	"What is on your mind?","What are you thinking about?",
	"What is bothering you?","What is challenging you?",
	"What do you need clarification on?","What do you want to understand better?",
	"What are you wondering about?"	,"What are you exploring?",
	"What is your inquiry?","What is your topic of interest?",
	"What is your concern?","What do you want to know?",
	"What is your problem?"}
local IDK={"I don’t know much about that topic… However, I can share this with you",
	"That’s not my area of expertise… But I have something else to tell you",
	"I’m not very familiar with that subject… However, I want to say this to you",
	"That’s beyond my knowledge… But I have something interesting to share with you",
	"I can’t comment on that… However, I’d like to tell you this",
	"I'm afraid I do not have much to say on that... But let me tell you this"}
local blacklistwords={"were" ,"we're" ,"we?" ,"when" ,"how" ,"where" ,"do" ,"more" ,"about" ,"tell" ,"me" ,"what" ,"is" ,"a" ,"the" ,"of" ,"i" ,"how" ,"we" ,"us" ,"their" ,"them" ,"you" ,"dark" ,"if" ,"there" ,"have" ,"many" ,"one" ,"important" ,"situation" ,"but" ,"can" ,"think" ,"wondering" ,"i'm" ,"im" ,"and" ,"an" ," " ,"thinking" ,"your" ,"hear" ,"else" ,"have" ,"things" ,"few" ,"or" ,"any" , "be" , "use", "made" , "may" , "give" 
	, "help" , "came" , "show"
	, "does" , "must" , "went" 
	, "need" , "try"  , "found"
	, "should" , "add" , "keep"
	, "start" , "saw" , "turn" 
	, "might" , "close" , "seem" 
	, "open" , "begin" , "got" 
	, "began" , "grow" , "took" 
	, "carry" , "hear" , "stop" , "miss" ,"are"}

local checkcontext=false
local function splitString(str)
	local words = {}
	for word in str:gmatch("%w+") do -- %w+ matches one or more alphanumeric characters
		table.insert(words, word) -- insert the word into the words array
	end
	return words
end	

local function countKeyword(str, keyword)
	local count = 0
	for _, word in ipairs(splitString(str)) do
		if word:lower() == keyword:lower() or word:lower().."?" == keyword:lower() or word:lower() == keyword:lower().."." or word:lower().."." == keyword:lower() or word:lower().."'s" == keyword:lower() or word:lower() == keyword:lower().."'s" then -- compare the words in lowercase
			count = count + 1 -- increment the count if there is a match
		end
	end
	return count
end
local function findBestMatch(strings, keyword)
	local bestMatch = nil -- the best match string
	local bestCount = 0 -- the highest count of keyword occurrences
	for _, str in ipairs(strings) do -- loop through the strings in the table
		local check=false
		for _, blkl in ipairs(blasklist) do 
			if str==blkl then
				check=true
			end
		end
		if check==false then
			local count = countKeyword(str, keyword) -- get the count of keyword occurrences in the string
			if count > bestCount then -- if the count is higher than the best count so far
				bestMatch = str -- update the best match string
				bestCount = count -- update the best count number
			end
		end	
	end
	return bestMatch, bestCount -- return the best match and its count
end

local function SearchQuery(query,database,filter,repetitive)
	local words = splitString(query) -- Split the query into words using your splitString function
	local matches = {} -- A table to store the matches and their scores
	local BlacklistedKeyword
	for _, word in ipairs(words) do -- Loop through the words in the query
		--Blacklist a bunch of nouns and non context wwords.
		if word~=nil then
			if filter==true then
				BlacklistedKeyword = table.find(blacklistwords, word)
			else
				BlacklistedKeyword = nil
			end
			if not BlacklistedKeyword then
				local bestMatch, bestCount = findBestMatch(database, word) -- Find the best match and its count for each word using your findBestMatch function
				if bestMatch then -- If there is a match
					if matches[bestMatch] then -- If the match is already in the table
						matches[bestMatch] = matches[bestMatch] + bestCount -- Add the count to its score
					else -- If the match is not in the table yet
						matches[bestMatch] = bestCount -- Set its score to the count
					end
				end	
			end
		end
	end
	local sortedMatches = {} -- A table to store the sorted matches by their scores
	for match, score in pairs(matches) do -- Loop through the matches and their scores
		table.insert(sortedMatches, {match = match, score = score}) -- Insert each match and its score as a subtable into the sortedMatches table
	end
	table.sort(sortedMatches, function(a, b) return a.score > b.score end) -- Sort the sortedMatches table by the score field in descending order
	local result = nil -- The result string to return
	if #sortedMatches > 0 then -- If there is at least one match
		--result = "The best match(es) for '" .. query .. "' are:\n" -- Start the result string with an introduction
		for i = 1, math.min(#sortedMatches, 3) do -- Loop through the top three matches or less if there are not enough matches
			result =  sortedMatches[i].match
			--.. " (Score: " .. sortedMatches[i].score .. ")\n" -- Append each match and its score to the result string
		end
		context=context+1
		if repetitive==false then
			table.insert(blasklist,result)
		end	
		--result=sortedMatches[math.random(1,math.min(#sortedMatches, 3))]
	else -- If there are no matches
		result=nil
		--result = "Sorry, I couldn't find any match for '" .. query .. "' in the database." -- Set the result string to an error message
	end
	return result
	-- Return the result string
end

local function randomizeString(str)
	-- Split the string into sentences
	local sentences = {}
	for s in str:gmatch("[^%.]+") do
		table.insert(sentences, s)
	end
	-- Loop through the sentences and replace any matching phrases with a random one from the table
	local newSentences = {}
	for i, s in ipairs(sentences) do
		local newS = s
		for j, phrases in ipairs(interchangephrases) do
			for k, phrase in ipairs(phrases) do
				if s:find(phrase) then
					-- Pick a random phrase from the same group
					local randomPhrase = phrases[math.random(#phrases)]
					-- Replace the original phrase with the random one
					newS = newS:gsub(phrase, randomPhrase)
					for i, s in ipairs(splitString(newS)) do
						local newS = s
						for j, phrases in ipairs(interchangephrases) do
							for k, phrase in ipairs(phrases) do
								if s:find(phrase) then
									-- Pick a random phrase from the same group
									local randomPhrase = phrases[math.random(#phrases)]
									-- Replace the original phrase with the random one
									newS = newS:gsub(phrase, randomPhrase)
									break
								end
							end
						end
						--table.insert(newSentences, newS)
					end
					break
				end
			end
		end

		table.insert(newSentences, newS)
	end

	-- Join the new sentences with periods and return the result
	return table.concat(newSentences, ".")
end

local function CompleteQuery(str,database,filter,repetitive)
	-- Split the string into sentences
	local sentences = {}
	local Result=nil
	for s in str:gmatch("[^%.]+") do
		table.insert(sentences, s)
	end
	-- Loop through the sentences and replace any matching phrases with a random one from the table
	local newSentences = {}
	Result=SearchQuery(str,database,filter,repetitive)

	if Result==nil then
		for i, s in ipairs(sentences) do
			local newS = s
			if Result==nil then
				for j, phrases in ipairs(interchangephrases) do
					if Result==nil then
						for k, phrase in ipairs(phrases) do
							if s:find(phrase) and Result==nil then 
								local combi=0
								repeat
									combi=combi+1
									local randomPhrase = phrases[combi]
									local newS1 = newS:gsub(phrase, randomPhrase)
									Result=SearchQuery(newS1,database,filter,repetitive)	
								until combi>=#phrases or Result~=nil
								if Result==nil then
									for i, s in ipairs(splitString(newS)) do
										local newS = s
										if Result==nil then
											for j, phrases in ipairs(interchangephrases) do
												if Result==nil then					
													for k, phrase in ipairs(phrases) do
														if s:find(phrase) and Result==nil then
															repeat
																combi=combi+1
																local randomPhrase = phrases[combi]
																if randomPhrase~=nil then
																	local newS1 = newS:gsub(phrase, randomPhrase)

																	Result=SearchQuery(newS1,database,filter,repetitive)

																end	
															until combi>=#phrases or Result~=nil
															break
														end
													end
												end
											end
										end
									end
								end
								break
							end
						end
					end
				end
			end
		end
	end
	return Result
end

function Chat()
	if script.Parent.Parent:FindFirstChild("ChatBox")~=nil then
		script.Parent.Parent:FindFirstChild("ChatBox"):Destroy()
	end	

	local ScreenGui = Instance.new("ScreenGui")
	ScreenGui.Parent = game:GetService("StarterGui")
	
	local Answer="What is you question?"
	-- Create a Frame object under the ScreenGui
	local Frame = Instance.new("Frame")
	Frame.Name="ChatBox"
	Frame.Parent = script.Parent.Parent
	Frame.Size = UDim2.new(1, 0,0.6, 0)-- Adjust the size as needed
	Frame.Position = UDim2.new(0, 0,0, 0) -- Adjust the position as needed
	Frame.BackgroundColor3 = Color3.new(1, 1, 1) -- Adjust the color as needed
	Frame.BackgroundTransparency=1
	-- Create a TextLabel object under the Frame to display the question
	local QuestionLabel = script.Parent
	QuestionLabel.Text="What is your question?"
	local AnswerBox = Instance.new("TextBox")
	AnswerBox.Parent = Frame
	AnswerBox.Size = UDim2.new(0.74, 0,0.14, 0) -- Adjust the size as needed
	AnswerBox.Position = UDim2.new(0.13, 0,0.02, 0) -- Adjust the position as needed
	AnswerBox.Text = "" -- Leave the text empty initially
	AnswerBox.TextColor3 = script.Parent.TextColor3-- Adjust the text color as needed
	AnswerBox.FontFace=script.Parent.FontFace
	AnswerBox.PlaceholderText="Type your answer here..."	
	AnswerBox.ZIndex=11
	AnswerBox.TextScaled = true -- Adjust the text scaling as needed
	AnswerBox.BackgroundTransparency=1
	AnswerBox.TextStrokeTransparency=0
	--AnswerBox.ClearTextOnFocus=fa
	-- Create a TextButton object under the Frame to allow the user to submit their answer
	local EnterButton = Instance.new("TextButton")
	EnterButton.TextColor3 = script.Parent.TextColor3-- Adjust the text color as needed
	EnterButton.FontFace=script.Parent.FontFace
	EnterButton.Parent = Frame
	EnterButton.Size = UDim2.new(0.12, 0,0.1, 20) -- Adjust the size as needed
	EnterButton.Position = UDim2.new(0.875, 0,1.5, -40) -- Adjust the position as needed
	EnterButton.Text = "Enter" -- Change the text as needed
	EnterButton.TextColor3 = Color3.new(1, 1, 1) -- Adjust the text color as needed
	EnterButton.TextScaled = true -- Adjust the text scaling as needed
	EnterButton.BackgroundColor3 = Color3.new(0, 0.5, 1) -- Adjust the background color as needed
	EnterButton.Style="RobloxButton"
	--local CloseButton=EnterButton:Clone()
	--CloseButton.Parent=Frame
	--CloseButton.Position=UDim2.new(0.08, 0,0.6, 0) 
	--CloseButton.Text="Back"
	-- Define a function to check if the user's answer is correct and display feedback		
	local function CheckAnswer(answer)
		--local answer = AnswerBox.Text -- Get the user's answer from the TextBox
		local Result	
		if answer ~="" then -- Change the correct answer as needed	

			Result=	CompleteQuery(answer, Greetings,false,false)		
			--	EnterButton.Text = "" -- Change the feedback text as needed
			--EnterButton.BackgroundColor3 = Color3.new(1, 0, 0) -- Change the feedback color as needed
		if Result==nil then
			Result=CompleteQuery(answer,Database,true,false)
		end
		if Result==nil then
			Result=CompleteQuery(answer,wisdom,true,false)
		end
		if Result==nil and checkcontext==false then
			
			checkcontext=true
			Result=CheckAnswer(blasklist[context])
			Result=IDK[math.random(1,#IDK)]..Result
		elseif Result==nil and checkcontext==true then
			
			checkcontext=false
			Result=IDK[math.random(1,#IDK)]..wisdom[math.random(1,#wisdom)]
			end	
		
				return  randomizeString(Result)
		else 
			Result=inquiry[math.random(1,#inquiry)]	
		end	
		end
	EnterButton.MouseButton1Click:Connect(function() QuestionLabel.Text =CheckAnswer(AnswerBox.Text) end)
	AnswerBox.FocusLost:Connect(function() QuestionLabel.Text =CheckAnswer(AnswerBox.Text) end)
end
Chat()
